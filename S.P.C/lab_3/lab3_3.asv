clear all;
close all;

Ttt = 10;

step_ki = 0.5;
step_kp = step_ki;

max_kp = 8;
max_ki = 4;

t_kp = step_kp:step_kp:max_kp;
t_ki = step_ki:step_ki:max_ki;

m_uchyb = zeros((max_ki/step_ki),(max_kp/step_kp));
%m_uchyb = zeros((max_ki/step_ki),(max_kp/step_kp));

best_c_k_uch = 99999999;
best_kp = 0;
best_ki = 0;

for i=1:1:(max_kp/step_kp)
    for j=1:1:(max_ki/step_ki)
        kp = t_kp(i);
        ki = t_ki(j);

        sim('simu3_31.slx');
        
        %warunek stabilno≈õci obliczony z kryterium Hurwitza  
        if (kp < 8)
            if (ki < ((-kp*kp+7*kp+8)/7))
                m_uchyb(i,j) = max(c_k_uch);
                if m_uchyb(i,j) > 100                   %uciecie duzych uchybow
                    m_uchyb(i,j) = 100;
                end
                if  m_uchyb(i,j) < best_c_k_uch         %sprawdzenie czy calka z kwadratu uchybu jest mniejsza od ostatniej najlepszej
                    if y(length(y))*1.1 < max(y)        %sprawdzenie czy maksymalne przeregulowanie jest mniejsze od 110% wartosci ustalonej
                        best_c_k_uch = m_uchyb(i,j);
                        best_kp = kp;
                        best_ki = ki;
                    end
                end    
            else
                m_uchyb(i,j) = -1;
            end
        else
            m_uchyb(i,j) = -1;
        end
        

    end
    fprintf('%i z %i\n', i, (max_kp/step_kp));
end  
surf(t_kp,t_ki,m_uchyb);

[x,y] = meshgrid(t_kp,t_ki);

xlabel('ki'), ylabel('kp'), zlabel('max calka kwadr. uchybu');  %to ma byc na odwrot!







